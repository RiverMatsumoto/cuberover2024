
import threading
import serial
from time import sleep

class SerialHandler:
    def __init__(self, port='/dev/ttyACM0', baudrate=115200, timeout=0.5,
                 write_interval=0.1, max_queue_length=20, serial_data_callback=None):
        self.serial_port = serial.Serial(port, baudrate)
        self.serial_port.timeout = timeout

        # will pass the serial data read to this function
        self.serial_data_callback = serial_data_callback

        # interval to prevent arduino serial from overflowing
        self.write_interval = write_interval

        self.msg_queue = []
        self.max_queue_length = max_queue_length

        self.read_thread = threading.Thread(target=self.threaded_read)
        self.read_thread.daemon = True
        self.read_thread.start()
    
    def write(self, msg: str):
        # discard message if msg_queue is full
        if len(self.msg_queue) < self.max_queue_length:
            self.msg_queue.append(msg)
    
    def threaded_read(self):
        while True:
            if self.serial_port.is_open and self.serial_port.in_waiting > 0:
                try:
                    line = self.serial_port.readline().strip().decode('utf-8')
                    if line:
                        self.serial_data_callback(line)
                except Exception as e:
                    print(f"Error reading serial data or sending data to callback: {e}")
                    break
            threading.Event().wait(self.read_interval)  # Control read rate

    def is_arduino_connected(self):
        devices = serial.tools.list_ports.comports()
        arduino_vendor_id = 0x2341  # Example Vendor ID (Arduino)
        arduino_product_id = 0x0043  # Example Product ID (Arduino Uno)
        for device in devices:
            if device.vid == arduino_vendor_id and device.pid == arduino_product_id:
                return True
        return False
    
    def close(self):
        self.serial_port.close()